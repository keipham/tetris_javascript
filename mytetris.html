<!-- CSS Code -->
<style>
/** {
    outline: 1px dotted red; 
}*/


body {
    background-image:    url("my_image.png");
    background-size:     cover;                      /* <------ */
    background-repeat:   no-repeat;
    background-position: center center;              /* optional, center the image */
    overflow: hidden;
}

body.active {
    background-image: none;
    background-color: #332E2E; 
}
.open-slide{
  float:left;
  display:block;
  color:#f2f2f2;
  text-align:center;
  padding:14px 16px;
  text-decoration:none;
  font-size:17px;
  transition:0.3s;
  position: absolute;
  top: 4%;
  left: 0%;
}

.side-nav{
  height:100%;
  position:absolute;
  z-index:1;
  top:0;
  left:0;
  background-color:#111;
  opacity:0.9;
  overflow-x:hidden;
  padding-top:60px;
  transition:0.5s;
}
.side-nav a{
  padding:10px 10px 10px 30px;
  border-bottom: 1px solid rgba(100,100,100,0.3);
  text-decoration:none;
  font-size:22px;
  color:#ccc;
  display:block;
  transition:0.3s;
}

.side-nav a:hover{
  color:#fff;
  font-size: 24px;
}

.side-nav .btn-close{
  position:absolute;
  top:0;
  right:22px;
  font-size:36px;
  margin-left:50px;
}
#main.active svg path{
  stroke: #f4f4f4;
}
#main{
  transition:margin-left 0.5s;
  padding:20px;
  overflow:hidden;
  width:100%;
  display: none;
  margin-left: 0px;
}
.title.active{
    color:#f4f4f4;
}
@keyframes fallDown {
    from {
        transform: translateY(0) rotate(0deg);
    }
    25%{
        transform: translateY(500px) rotate(90deg); 
    }
    50%{
        transform: translateY(1000px) rotate(180deg);
    }
    75%{
        transform: translateY(2000px) rotate(270deg);
    }
    to {
        transform: translateY(2000px) rotate(360deg);
    }
}

@keyframes title_blink {
    from {
        color: orange;
    }
    25%{
        color: green;
    }
    50%{
        color: blue;
    }
    75%{
        color: pink;
    }
    to {
        color: red;
    }
}        

h1{
    text-align: center;
    font-size: 100px;
    position: relative;
    top: 60px;
    animation: title_blink 50s infinite;
}

.cell {
    width: 50px;
    height: 50px;
    display: inline-block;
}
.empty {
    outline: 1px dotted blue;
}

.squareShape {
    background-color: orange;
    outline: 2px solid black;
}

.barShape {
    background-color: green;
    outline: 2px solid black;
}

.zShape {
    background-color: blue;
    outline: 2px solid black;
}

.reverseZshape {
    background-color: red;
    outline: 2px solid black;
}

.lShape {
    background-color: pink;
    outline: 2px solid black;
}

.reverseLshape{
    background-color: darkmagenta;
    outline: 2px solid black;
}
.pyramid {
    background-color:violet;
    outline: 2px solid black;
}

#world{
    text-align: center; 
}

.restart{
    background-color: #f4f4f4;
    border: none;
    border-radius: 34px;
    color: #332E2E;
    transition-duration: 0.3s;
    padding: 15px 32px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 19px;
    margin: 4px 2px;
    cursor: pointer;
    position: relative;
    top: 50px;
}

.restart:hover {
  background-color: #332E2E; 
  color: #f4f4f4;
}


.details {
    flex-direction: column;
    position: absolute;
    font-size: 40px;
    text-align: center;
    top: 25%;
    left: 65%;
    width: 21%;
}
.mode{
    font-size: 17px;
    position: relative;
    left: 20%;
    top: 1%;
}

.mode.active{
    color: #f4f4f4;
}
.lines, .level, .score {  
    position: relative;
    text-align: center;
    top: 10px;
    border-radius: 25px;
    background-color: white;
}

.lines.active, .level.active, .score.active {  
    position: relative;
    text-align: center;
    top: 10px;
    border-radius: 25px;
    background-color: white;
    color: #000;
}

.title {
    /*font-size: 20px;*/
    text-align: center;
    font-size: 40px;
    margin-top: 9%;
    /*outline: 4px dotted blue;*/
}

.best-title{
    outline: 4px solid gold;
    color: gold;
}

select{
    position: relative;
    margin-top: 10px;
    font-size: 20px;
    width: 160px;
    text-align: center;
    font-size: 25px;
}
#ruins{
    display: inline-block;
    position: relative;
    border-color: black;
    top: -1250px;
    left: 9%;
    animation: fallDown 9s infinite linear;
}
/* The switch - the box around the slider */
.switch {
  position: absolute;
  display: inline-block;
  width: 60px;
  height: 34px;
  right:4%;
  top: -8%;
}

/* Hide default HTML checkbox */
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

/* The slider */
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  /*-webkit-transition: .4s;*/
  transition: .4s;
}

input:checked + .slider {
  background-color: #2196F3;
}

input:focus + .slider {
  box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
  /*-webkit-transform: translateX(26px);*/
  -ms-transform: translateX(26px);
  transform: translateX(26px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 34px;
}

.slider.round:before {
  border-radius: 50%;
}
@media (max-width: 1900px) {
  .title {
    font-size: 30px;
    text-align: center;
    margin-top: 9%;
    }
  .cell {
    width: 40px;
    height: 40px;
    display: inline-block;
    }
    #mode{
        display: none;
    }
}

@media (max-width: 1500px) {
    .title {
    font-size: 20px;
    text-align: center;
    margin-top: 9%;
    }
  .cell {
    width: 35px;
    height: 35px;
    display: inline-block;
    }
    #mode{
        display: none;
    }
}
@media (max-width: 1250px) {
    #ruins{
        display:none;
    }
    #body .details{
        display: none;
    }
    #main{
        transition:margin-left 0.5s;
        padding:20px;
        overflow:hidden;
        width:100%;
        display: inline-block;
    }
    h1{
        text-align: center;
        font-size: 50px;
        position: relative;
        top: 20px;
        animation: title_blink 50s infinite;
    }
    
    #side-menu .details{
        display: inline-block;
        flex-direction: column;
        position: absolute;
        font-size: 20px;
        text-align: center;
        top: 10%;
        left: 20%;
        width: auto;
        padding-top: 20%;
    }
    .title {
        font-size: 25px;
        text-align: center;
        margin-top: 9%;
        color: #f4f4f4;
    }
    .best-title {
        outline: 4px solid gold;
        color: gold;
    }
    .lines, .level, .score {  
        color: black;
    }
    
}
@media (max-width: 750px) {
    .title {
        font-size: 25px;
    }
}
</style>


<!-- HTML Code -->
<!DOCTYPE html>
<body id="body">
    <h1>TETRIS</h1>
    <div id='world'></div>
    <div id='ruins'></div>
    <div id="side-menu" class="side-nav" style="width: 0px">
        <ul>
            <li><a href="#" class="btn-close" onclick="closeSlideMenu()">&times;</a></li>
        </ul>
        <div class='details'>
            <label class="switch">
                <span class='mode'><!--switch light--></span>
                <input type="checkbox" onclick="night(this)">
                <span class="slider round"></span>
            </label>
            <div class='title best-title'>BEST SCORE
                <div class='best'>
                </div>
            </div>
            <div class='title'>SCORE
                <div class='score'>
                </div>
            </div>
            <div class='title'>LINES
                <div class='lines'>
                </div>
            </div>
            <div class='title'>LEVEL
                <div class='level'>
                </div>
            </div>
            <a class='restart' onclick="window.location.reload()">Restart</a>         
        </div>
    </div>
    
    <div id="main">
        <span class="open-slide">
            <a href="#" onclick="toggleSlideMenu()">
            <svg width="30" height="30">
                <path d="M0,5 30,5" stroke="#000" stroke-width="5"/>
                <path d="M0,14 30,14" stroke="#000" stroke-width="5"/>
                <path d="M0,23 30,23" stroke="#000" stroke-width="5"/>
            </svg>
            </a>
        </span>
    </div>
    <div class='details'>
        <label class="switch">
            <span class='mode'><!--switch light--></span>
            <input type="checkbox" onclick="night(this)">
            <span class="slider round"></span>
        </label>
        <div class='title best-title'>BEST SCORE
            <div class='best'>
            </div>
        </div>
        <div class='title'>SCORE
            <div class='score'>
            </div>
        </div>
        <div class='title'>LINES
            <div class='lines'>
            </div>
        </div>
        <div class='title'>LEVEL
            <div class='level'>
            </div>
        </div>
        <a class='restart' onclick="window.location.reload()">Restart</a>   
    </div>
    
</body>
</html>

<!-- JavaScript Code: -->
<script>
function toggleSlideMenu(){
      var menu = document.getElementById('side-menu');
      var main = document.getElementById('main');
      if (menu.style.width === '0px'){
        if (window.matchMedia("(max-width: 750px)").matches) {
        /* the view port is maximum 400 pixels wide */
            menu.style.width = '60%';
            main.style.marginLeft = '60%';
        } else {
            menu.style.width = '30%';
            main.style.marginLeft = '30%';
        }  
      } else {
        menu.style.width = '0';
        main.style.marginLeft = '0';
      }
    }

function closeSlideMenu(){
    document.getElementById('side-menu').style.width = '0';
    document.getElementById('main').style.marginLeft = '0';
}
var world = [
    [0,0,0,0,4,4,0,0,0,0],
    [0,0,0,0,4,4,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0]
];

var ruins = [
    [0,0,0,0,4,4,0,0,0,0],
    [0,0,0,0,4,4,0,0,0,0]
];

function drawWorld() {
    document.getElementById('world').innerHTML = "";
    for(var y=0; y<world.length; y++) {
        for(var x=0; x<world[y].length; x++) {
            if(world[y][x]=== 0){
                document.getElementById('world').innerHTML += "<div class='cell empty'></div>";
            } else if(world[y][x]=== 1 || world[y][x]=== 11){
                document.getElementById('world').innerHTML += "<div class='cell barShape'></div>";
            } else if(world[y][x]=== 2 || world[y][x]=== 12){
                document.getElementById('world').innerHTML += "<div class='cell lShape'></div>";
            } else if(world[y][x]=== 3 || world[y][x]=== 13){
                document.getElementById('world').innerHTML += "<div class='cell zShape'></div>";
            } else if(world[y][x]=== 4 || world[y][x]=== 14){
                document.getElementById('world').innerHTML += "<div class='cell squareShape'></div>";
            } else if(world[y][x]=== 5 || world[y][x]=== 15){
                document.getElementById('world').innerHTML += "<div class='cell reverseZshape'></div>";
            } else if(world[y][x]=== 6 || world[y][x]=== 16){
                document.getElementById('world').innerHTML += "<div class='cell pyramid'></div>";
            } else if(world[y][x]=== 7 || world[y][x]=== 17){
                document.getElementById('world').innerHTML += "<div class='cell reverseLshape'></div>";
            }
        }
        document.getElementById('world').innerHTML += "<br>";
    }
}

function drawRuins() {
    document.getElementById('ruins').innerHTML = "";
    for(var y=0; y<ruins.length; y++) {
        for(var x=0; x<ruins[y].length; x++) {
            if(ruins[y][x]=== 0){
                document.getElementById('ruins').innerHTML += "<div class='cell'></div>";
            } else if(ruins[y][x]=== 1){
                document.getElementById('ruins').innerHTML += "<div class='cell barShape'></div>";
            } else if(ruins[y][x]=== 2){
                document.getElementById('ruins').innerHTML += "<div class='cell lShape'></div>";
            } else if(ruins[y][x]=== 3){
                document.getElementById('ruins').innerHTML += "<div class='cell zShape'></div>";
            } else if(ruins[y][x]=== 4){
                document.getElementById('ruins').innerHTML += "<div class='cell squareShape'></div>";
            } else if(ruins[y][x]=== 5){
                document.getElementById('ruins').innerHTML += "<div class='cell reverseZshape'></div>";
            } else if(ruins[y][x]=== 6){
                document.getElementById('ruins').innerHTML += "<div class='cell pyramid'></div>";
            } else if(world[y][x]=== 7){
                document.getElementById('ruins').innerHTML += "<div class='cell reverseLshape'></div>";
            }
        }
        document.getElementById('ruins').innerHTML += "<br>";
    }
}
function moveShapesDown() {
    canMove = true;
    for(var y=world.length-1; y>=0; y--) {
        for(var x=0; x<world[y].length; x++) {
            if(world[y][x] > 0 && world[y][x] < 10 ){
                if(y+1 === world.length || world[y+1][x] > 10){
                    canMove = false;
                    freeze();
                }
            }
        }
    }
    if (canMove) {
        for(var y=world.length-1; y>=0; y--) {
            for(var x=0; x<world[y].length; x++) {
                if(world[y][x] > 0 && world[y][x] < 10 ){
                    world[y+1][x] = world[y][x];
                    world[y][x] = 0;
                }
            }
        }
        drawWorld();
    }
    checkLines();
}
function moveShapesLeft() {
    canMove = true;
    for(var y=world.length-1; y>=0; y--) {
        for(var x=0; x<world[y].length; x++) {
            if(world[y][x] > 0 && world[y][x] < 10 ){
                if(x === 0 || world[y][x-1] > 10){
                    canMove = false;
                }
            }
        }
    }
    if (canMove) {
        for(var y=world.length-1; y>=0; y--) {
            for(var x=0; x<world[y].length; x++) {
                if(world[y][x] > 0 && world[y][x] < 10 ){
                    world[y][x-1] = world[y][x];
                    world[y][x] = 0;
                }
            }
        }
        drawWorld();
    }
}
function moveShapesRight() {
    canMove = true;
    for(var y=world.length-1; y>=0; y--) {
        for(var x=0; x<world[y].length; x++) {
            if(world[y][x] > 0 && world[y][x] < 10 ){
                if(x === 9 || world[y][x+1] > 10){
                    canMove = false;
                }
            }
        }
    }
    if (canMove) {
        for(var y=world.length-1; y>=0; y--) {
            for(var x=world[y].length; x>=0; x--) {
                if(world[y][x] > 0 && world[y][x] < 10 ){
                    world[y][x+1] = world[y][x];
                    world[y][x] = 0;
                }
            }
        }
        drawWorld();
    }
}
function rotateShapeRight() {
    canMove = true;
    for(var y=world.length-1; y>=0; y--) {
        for(var x=0; x<world[y].length; x++) {
            if(world[y][x] > 0 && world[y][x] < 10 ){
                if(world[y+1][x] > 10 || world[y-1][x] > 10){
                    canMove = false;
                }
            }
        }
    }
    if (canMove) {
        var turn = 0;
        //the variable "turn" allows the function to work only once when the first cell of the shape is met by the loop AND not for EVERY cell of the shape
        for(var y=world.length-1; y>=0; y--) {
            for(var x=0; x<world[y].length; x++) {
                if(world[y][x] > 0 && world[y][x] < 10 ){
                    if (world[y][x] === 1 && turn === 0){
                        if (world[y-1][x] === 1){
                            //The barShape (value=1) is VERTICAL
                            if (count%3 === 0){
                                //My shape will rotate on the second cell of my shape (from the top)
                                if (world[y-2][x+1] != 0 && world[y-2][x-1] === 0 && world[y-2][x-2] === 0 && world[y-2][x-3] === 0){
                                    //If my shape is blocked on the right side but free on the left side
                                    world[y-2][x-1] = world[y][x];
                                    world[y-2][x-2] = world[y-1][x];
                                    world[y-2][x-3] = world[y-3][x];
                                    //I reset to 0 the cases that should now be empty
                                    world[y][x] = 0;
                                    world[y-1][x] = 0;
                                    world[y-3][x] = 0;
                                } else if (world[y-2][x-1] != 0 && world[y-2][x+1] === 0 && world[y-2][x+2] === 0 && world[y-2][x+3] === 0){
                                    //If my shape is blocked on the left side (no space on the left) but free on the right side
                                    world[y-2][x+1] = world[y][x];
                                    world[y-2][x+2] = world[y-1][x];
                                    world[y-2][x+3] = world[y-3][x];  
                                    //I reset to 0 the cases that should now be empty
                                    world[y][x] = 0;
                                    world[y-1][x] = 0;
                                    world[y-3][x] = 0;
                                } else if (world[y-2][x-1] === 0 && world[y-2][x-2] === 0 && world[y-2][x+1] === 0){
                                    //If the shape can move freely
                                    world[y-2][x-1] = world[y-3][x];
                                    world[y-2][x+1] = world[y-1][x];
                                    world[y-2][x-2] = world[y][x];
                                    //I reset to 0 the cases that should now be empty
                                    world[y-3][x] = 0;
                                    world[y-1][x] = 0;
                                    world[y][x] = 0;
                                }
                            } else if (count%3 !== 0){
                                //My shape will rotate on the third cell of my shape (from the top)
                                if (world[y-1][x-1] != 0 && world[y-1][x+1] === 0 && world[y-1][x+2] === 0 && world[y-1][x+3] === 0){
                                    //If my shape is blocked on the left side but free on the right side
                                    world[y-1][x+1] = world[y][x];
                                    world[y-1][x+2] = world[y-2][x];
                                    world[y-1][x+3] = world[y-3][x];  
                                    //I reset to 0 the cases that should now be empty
                                    world[y][x] = 0;
                                    world[y-2][x] = 0;
                                    world[y-3][x] = 0;
                                } else if (world[y-1][x+1] != 0 && world[y-1][x-1] === 0 && world[y-1][x-2] === 0 && world[y-1][x-3] === 0) {
                                    //If my shape is blocked on the right side but free on the left side
                                    world[y-1][x-1] = world[y][x];
                                    world[y-1][x-2] = world[y-2][x];
                                    world[y-1][x-3] = world[y-3][x];
                                    //I reset to 0 the cases that should now be empty
                                    world[y][x] = 0;
                                    world[y-2][x] = 0;
                                    world[y-3][x] = 0;
                                } else if (world[y-1][x-1] === 0 && world[y-1][x+1] === 0 && world[y-1][x+2] === 0){
                                    //my shape is free to move
                                    world[y-1][x-1] = world[y-2][x];
                                    world[y-1][x+1] = world[y][x];
                                    world[y-1][x+2] = world[y-3][x];
                                    //I reset to 0 the cases that should now be empty
                                    world[y-3][x] = 0;
                                    world[y-2][x] = 0;
                                    world[y][x] = 0;
                                }
                            }
                        } else if (world[y-1][x] === 0){
                            //The barShape (value=1) is HORIZONTAL
                            if (count%3 === 0){
                                world[y-1][x+1] = world[y][x];
                                world[y+1][x+1] = world[y][x+2];
                                world[y+2][x+1] = world[y][x+3];
                                //I reset to 0 the cases that should now be empty
                                world[y][x] = 0;
                                world[y][x+2] = 0;
                                world[y][x+3] = 0;
                            } else if (count%3 !== 0){
                                world[y-1][x+2] = world[y][x+1];
                                world[y-2][x+2] = world[y][x];
                                world[y+1][x+2] = world[y][x+3];
                                //I reset to 0 the cases that should now be empty
                                world[y][x+1] = 0;
                                world[y][x+3] = 0;
                                world[y][x] = 0;
                            }                                
                        }
                    } else if (world[y][x] === 2 && turn === 0){
                        //value 2 = L shape
                        if (world[y][x+1] === 2 && world[y-1][x] === 2 && world[y-2][x] === 2){
                            //The shape points to the top and will rotate clockwise
                            if (world[y][x+2] !== 0 && world[y+1][x-1] === 0){
                                //If the shape is blocked on the right side
                                world[y][x-1] = world[y-1][x];
                                world[y+1][x-1] = world[y-2][x];
                                //I reset to 0 the cases that should now be empty
                                world[y-1][x] = 0;
                                world[y-2][x] = 0;
                              } else {
                                //If the shape can move freely
                                world[y+1][x] = world[y][x+1];
                                world[y][x+2] = world[y-2][x];
                                //I reset to 0 the cases that should now be empty
                                world[y-1][x] = 0;
                                world[y-2][x] = 0;
                            }
                        } else if (world[y-1][x] === 2 && world[y-1][x+1] === 2 && world[y-1][x+2] === 2){
                            //The shape points right and will rotate clockwise
                            if (world[y-1][x-1] !== 0 && world[y+1][x] === 0){
                                //The shape is blocked on the left side
                                world[y][x+1] = world[y][x];
                                world[y+1][x+1] = world[y-1][x+2];
                                //I reset to 0 the cases that should now be empty
                                world[y][x] = 0;
                                world[y-1][x+2] = 0;
                            } else if (world[y-1][x-1] === 0 && world[y+1][x] === 0){
                                //The shape can move freely
                                world[y-1][x-1] = world[y][x];
                                world[y+1][x] = world[y-1][x+1];
                                //I reset to 0 the cases that should now be empty
                                world[y-1][x+1] = 0;
                                world[y-1][x+2] = 0; 
                            }                      
                        } else if (world[y-1][x] === 2 && world[y-2][x] === 2 && world[y-2][x-1] === 2){
                            //The shape points to the bottom and will rotate clockwise
                            if (world[y-2][x-2] !== 0){
                                world[y-2][x+1] = world[y][x];
                                world[y-3][x+1] = world[y-1][x];
                                //I reset to 0 the cases that should now be empty
                                world[y][x] = 0;
                                world[y-1][x] = 0;
                            } else if (world[y-2][x-2] === 0){
                                world[y-2][x-2] = world[y][x];
                                world[y-3][x] = world[y-1][x];
                                //I reset to 0 the cases that should now be empty
                                world[y][x] = 0;
                                world[y-1][x] = 0; 
                            }
                        } else if (world[y][x+1] === 2 && world[y][x+2] === 2 && world[y-1][x+2] === 2){
                            //the shape points left and will rotate clockwise
                            world[y][x+3] = world[y-1][x+2];
                            world[y-2][x+2] = world[y][x+2];
                            //I reset to 0 the cases that should now be empty
                            world[y][x] = 0;
                            world[y][x+1] = 0;
                        }
                    } else if (world[y][x] === 3 && turn === 0){
                        // value 3 = Z shape
                        if (world[y][x+1] === 3 && world[y-1][x] === 3 && world[y-1][x-1] === 3){
                            //The shape looks like a Z and will rotate clockwise
                            world[y+1][x] = world[y-1][x-1];
                            world[y-1][x+1] = world[y-1][x];
                            //I reset to 0 the cases that should now be empty
                            world[y-1][x-1] = 0;
                            world[y-1][x] = 0;
                        } else if (world[y-1][x] === 3 && world[y-1][x+1] === 3 && world[y-2][x+1] === 3){
                            //The shape looks like a N and will rotate clockwise
                            if (world[y-1][x-1] === 0 && world[y][x+1] === 0){
                                //If my shape can move freely
                                world[y-1][x-1] = world[y-1][x+1];
                                world[y][x+1] = world[y-2][x+1];
                                //I reset to 0 the cases that should now be empty
                                world[y-1][x+1] = 0;
                                world[y-2][x+1] = 0;
                            } else if (world[y-1][x-1] !== 0 && world[y][x+1] === 0 && world[y][x+2] === 0){
                                //If my shape is blocked on the left side but is free on the right side
                                world[y][x+1] = world[y][x];
                                world[y][x+2] = world[y-2][x+1];
                                //I reset to 0
                                world[y][x] = 0;
                                world[y-2][x+1] = 0;
                            }
                          
                        }                      
                    } else if (world[y][x] === 5 && turn === 0){
                        //value 5 = S shape
                        if (world[y][x+1] === 5 && world[y-1][x+1] === 5 && world[y-1][x+2] === 5){
                            //The shape looks like a S
                            if (world[y+1][x+1] === 0 && world[y-1][x] === 0){
                                world[y+1][x+1] = world[y-1][x+2];
                                world[y-1][x] = world[y-1][x+1];
                                //I reset to 0
                                world[y-1][x+2] = 0;
                                world[y-1][x+1] = 0;
                            } else if (world[y+1][x+1] !== 0 && world[y-1][x] === 0){
                                world[y-2][x] = world[y-1][x+2];
                                world[y-1][x] = world[y][x];
                                //I reset to 0 the cases that should now be empty
                                world[y-1][x+2] = 0;
                                world[y][x] = 0;
                            }                             
                        } else if (world[y-1][x] === 5 && world[y-1][x-1] === 5 && world[y-2][x-1] === 5){
                            // The shape looks like a reverse N
                            if (world[y-1][x+1] === 0 && world[y][x-1] === 0){
                                //If my shape can move freely
                                world[y-1][x+1] = world[y-2][x-1];
                                world[y][x-1] = world[y-1][x-1];
                                //I reset to 0 the cases that should now be empty
                                world[y-2][x-1] = 0;
                                world[y-1][x-1] = 0;
                            } else if (world[y-1][x+1] !== 0 && world[y][x-1] === 0 && world[y][x-2] === 0){
                                //If my shape is blocked on the right side but free on the left side
                                world[y][x-1] = world[y][x];
                                world[y][x-2] = world[y-2][x-1];
                                //I reset to 0
                                world[y][x] = 0;
                                world[y-2][x-1] = 0;
                            }
                         
                        }
                    } else if (world[y][x] === 6 && turn === 0){
                        //value 6 = pyramid
                        if (world[y][x+1] === 6 && world[y][x+2] === 6){
                            //the pyramid points to the top and will rotate clock wise
                            if (world[y+1][x+1] === 0){
                                //shape can move freely
                                world[y+1][x+1] = world[y][x];
                                //I reset to 0
                                world[y][x] = 0;
                            }
                        } else if (world[y-1][x] === 6 && world[y-2][x] === 6 && world[y-1][x+1] === 6){
                            //the shape points right and will rotate clockwise
                            if (world[y-1][x-1] === 0){
                                //can move freely
                                world[y-1][x-1] = world[y-2][x];
                                //I reset to 0
                                world[y-2][x] = 0;
                            } else if (world[y-1][x-1] !== 0){
                                //shape blocked on the left side
                                world[y-1][x+2] = world[y][x];
                                world[y-2][x+1] = world[y-2][x];
                                //I reset to 0;
                                world[y][x] = 0;
                                world[y-2][x] = 0;
                            }
                        } else if (world[y-1][x-1] === 6 && world[y-1][x] === 6 && world[y-1][x+1] === 6){
                            //The shape points to the bottom and will rotate clockwise
                            if (world[y-2][x] === 0){
                                world[y-2][x] = world[y-1][x+1];
                                //I reset
                                world[y-1][x+1] = 0;
                            }
                        } else if (world[y-1][x-1] === 6 && world[y-1][x] === 6 && world[y-2][x] === 6){
                            //The shape points left
                            if (world[y-1][x+1] === 0){
                                world[y-1][x+1] = world[y][x];
                                world[y][x] = 0;
                            } else if (world[y-1][x+1] !== 0){
                                world[y-1][x-2] = world[y][x];
                                world[y-2][x-1] = world[y-2][x];
                                //I reset
                                world[y][x] = 0;
                                world[y-2][x] = 0;
                            }
                        }
                    } else if (world[y][x] === 7 && turn === 0){
                        //value 7 = reverse L shape
                        if (world[y][x+1] === 7 && world[y-1][x+1] === 7 && world[y-2][x+1] === 7){
                            //The shape points to the top and will rotate clockwise
                            if (world[y][x+2] !== 0 && world[y-1][x] === 0 && world[y-1][x-1] === 0 && world[y-2][x-1] === 0){
                                //If the shape is blocked on the right side
                                world[y-1][x] = world[y][x];
                                world[y-1][x-1] = world[y][x+1];
                                world[y-2][x-1] = world[y-2][x+1];
                                //I reset to 0 the cases that should now be empty
                                world[y][x] = 0;
                                world[y][x+1] = 0;
                                world[y-2][x+1] = 0;
                              } else if (world[y-1][x] === 0 && world[y-2][x] === 0 && world[y-1][x+2] === 0){
                                //If the shape can move freely
                                world[y-1][x] = world[y][x];
                                world[y-2][x] = world[y][x+1];
                                world[y-1][x+2] = world[y-2][x+1];
                                //I reset to 0 the cases that should now be empty
                                world[y][x] = 0;
                                world[y][x+1] = 0;
                                world[y-2][x+1] = 0;
                            }
                        } else if (world[y-1][x] === 7 && world[y][x+1] === 7 && world[y][x+2] === 7){
                            //The shape points right and will rotate clockwise
                            if (world[y+1][x] === 0 && world[y+2][x] === 0){
                                //The shape can move freely
                                world[y+1][x] = world[y-1][x];
                                world[y+2][x] = world[y][x+2];
                                //I reset to 0 the cases that should now be empty
                                world[y-1][x] = 0;
                                world[y][x+2] = 0; 
                            }                      
                        } else if (world[y-1][x] === 7 && world[y-2][x] === 7 && world[y-2][x+1] === 7){
                            //The shape points to the bottom and will rotate clockwise
                            if (world[y-1][x-1] !== 0 && world[y-1][x+1] === 0 && world[y-1][x+2] === 0 && world[y][x+2] === 0){
                                //The shape is blocked on the left side
                                world[y-1][x+1] = world[y][x];
                                world[y-1][x+2] = world[y-2][x];
                                world[y][x+2] = world[y-2][x+1];
                                //I reset to 0 the cases that should now be empty
                                world[y][x] = 0;
                                world[y-2][x] = 0;
                                world[y-2][x+1] = 0;
                            } else if (world[y-1][x-1] === 0 && world[y-1][x+1] === 0 && world[y][x+1] === 0){
                                //Shape can move freely
                                world[y-1][x-1] = world[y][x];
                                world[y-1][x+1] = world[y-2][x];
                                world[y][x+1] = world[y-2][x+1];
                                //I reset to 0 the cases that should now be empty
                                world[y][x] = 0;
                                world[y-2][x] = 0;
                                world[y-2][x+1] = 0; 
                            }
                        } else if (world[y-1][x] === 7 && world[y-1][x-1] === 7 && world[y-1][x-2] === 7){
                            //the shape points left and will rotate clockwise
                            if (world[y-2][x] === 0 && world[y-3][x] === 0){
                                world[y-2][x] = world[y][x];
                                world[y-3][x] = world[y-1][x-2];
                                //I reset to 0 the cases that should now be empty
                                world[y][x] = 0;
                                world[y-1][x-2] = 0;
                            }
                        }
                    }
                    turn++;
                }
            }
        }
        drawWorld();
    }
}
function freeze(){
    for(var y=world.length-1; y>=0; y--) {
        for(var x=0; x<world[y].length; x++) {
            if(world[y][x] > 0 && world[y][x] < 10 ){
                world[y][x] = world[y][x] + 10;
            }
        }
    }
    checkLines();
    var ran = Math.floor(Math.random()*7);
    if(ran === 0 && world[0][5] === 0 && world[1][5] === 0 && world[2][5] === 0 && world[3][5] === 0){
        //bar shape
        world[0][5] = 1;
        world[1][5] = 1;
        world[2][5] = 1;
        world[3][5] = 1; 
    } else if (ran === 1 && world[0][4] === 0 && world[1][4] === 0 && world[2][4] === 0 && world[2][5] === 0){
        //L shape
        world[0][4] = 2;
        world[1][4] = 2;
        world[2][4] = 2;
        world[2][5] = 2;
    } else if (ran === 2 && world[0][4] === 0 && world[0][5] === 0 && world[1][5] === 0 && world[1][6] === 0){
        //Z shape
        world[0][4] = 3;
        world[0][5] = 3;
        world[1][5] = 3;
        world[1][6] = 3;
    } else if (ran === 3 && world[0][4] === 0 && world[0][5] === 0 && world[1][4] === 0 && world[1][5] === 0){
        //cube
        world[0][4] = 4;
        world[0][5] = 4;
        world[1][4] = 4;
        world[1][5] = 4;
    } else if (ran === 4 && world[0][4] === 0 && world[0][5] === 0 && world[1][3] === 0 && world[1][4] == 0){
        //S shape
        world[0][4] = 5;
        world[0][5] = 5;
        world[1][3] = 5;
        world[1][4] = 5;
    } else if (ran === 5 && world[0][5] === 0 && world[1][4] === 0 && world[1][5] === 0 && world[1][6] === 0) {
        //Pyramid shape
        world[0][5] = 6;
        world[1][4] = 6;
        world[1][5] = 6;
        world[1][6] = 6;
    } else if (ran === 6 && world[0][4] === 0 && world[1][4] === 0 && world[2][4] === 0 && world[2][3] === 0){
        //reverseLshape
        world[0][4] = 7;
        world[1][4] = 7;
        world[2][4] = 7;
        world[2][3] = 7;
    } else {
        if (score >= localStorage.getItem('best-score')){
            alert("Congrats ! This is your new best score: "+score);
        } else if (score < localStorage.getItem('best-score')){
            alert("Too bad! Try again!");
        }     
    } 
}

function checkLines(){
    var nbFullLine = 0;
    for(var y=world.length-1; y>=0; y--) {
        fullLine = true;
        for(var x=0; x<world[y].length; x++) {
            if(world[y][x] < 10) {
                fullLine = false;
            }
        }
        if (fullLine) {
            world.splice(y, 1);
            world.splice(0, 0, [0,0,0,0,0,0,0,0,0,0]);
            //nbFullLine keeps track of the number of line destroyed at the same time to determine the appropriate score
            nbFullLine++;
            //line_count allows to track number of line remaining before next level
            line_count ++;
            //lines keeps track of the number of lines destroyed
            lines++;
            document.getElementsByClassName('lines')[0].innerHTML = lines;
            document.getElementsByClassName('lines')[1].innerHTML = lines;
        }
    }
    if (nbFullLine === 1){
        score = score + 40*(level+1);
        document.getElementsByClassName('score')[0].innerHTML = score;
        document.getElementsByClassName('score')[1].innerHTML = score;
    } else if (nbFullLine === 2){       
        score = score + 100*(level+1);
        document.getElementsByClassName('score')[0].innerHTML = score;
        document.getElementsByClassName('score')[1].innerHTML = score;        
    } else if (nbFullLine === 2){       
        score = score + 100*(level+1);
        document.getElementsByClassName('score')[0].innerHTML = score;
        document.getElementsByClassName('score')[1].innerHTML = score;
    } else if (nbFullLine === 3){       
        score = score + 300*(level+1);
        document.getElementsByClassName('score')[0].innerHTML = score;
        document.getElementsByClassName('score')[1].innerHTML = score;
    } else if (nbFullLine === 4){       
        score = score + 1200*(level+1);
        document.getElementsByClassName('score')[0].innerHTML = score;
        document.getElementsByClassName('score')[1].innerHTML = score;
    }
        if (score > localStorage.getItem('best-score')){
            localStorage.setItem('best-score', score);
        }
        document.getElementsByClassName('best')[0].innerHTML = localStorage.getItem('best-score');
        document.getElementsByClassName('best')[1].innerHTML = localStorage.getItem('best-score');
    
}

function levelup(){
    if (line_count != 0 && line_count>=(5*level)){
        level++;
        document.getElementsByClassName('level')[0].innerHTML = level;
        document.getElementsByClassName('level')[1].innerHTML = level;
        line_count = 0;
        if (game_speed <= 250 && game_speed >= 50){
            game_speed = game_speed-20;
        } else if (game_speed <= 50){
            //no change of speed
        } else {
            game_speed = game_speed-150;
        }
    }
}
document.onkeydown = function(e) {
    if (e.keyCode === 37){
        moveShapesLeft(); 
    } else if (e.keyCode === 39){
        moveShapesRight();
    } else if (e.keyCode === 40){
        moveShapesDown();
    } else if (e.keyCode === 38){
        rotateShapeRight();
        if (count === 3){
            count = 0;
        };
        count++;
    }
}
function gameLoop(){
    moveShapesDown();
    drawWorld();
    levelup();
    setTimeout(gameLoop, game_speed);
}

function ruinsLoop(){
    var raandom = Math.floor(Math.random()*6);
    if(raandom === 0){
        //bar shape
        ruins = [
            [0,0,0,0,1,0,0,0,0,0],
            [0,0,0,0,1,0,0,0,0,0],
            [0,0,0,0,1,0,0,0,0,0],
            [0,0,0,0,1,0,0,0,0,0]
            ];
    } else if (raandom === 1){
        //L shape
        ruins = [
            [0,0,0,0,2,0,0,0,0,0],
            [0,0,0,0,2,0,0,0,0,0],
            [0,0,0,0,2,2,0,0,0,0]
           
            ];
    } else if (raandom === 2){
        //Z shape
        ruins = [
            [0,0,0,3,3,0,0,0,0,0],
            [0,0,0,0,3,3,0,0,0,0]
         
            ];
    } else if (raandom === 3){
        //cube
        ruins = [
            [0,0,0,0,4,4,0,0,0,0],
            [0,0,0,0,4,4,0,0,0,0]
          
            ];
    } else if (raandom === 4){
        //S shape
        ruins = [
            [0,0,0,0,5,5,0,0,0,0],
            [0,0,0,5,5,0,0,0,0,0]
          
            ];
    } else if (raandom === 5) {
        //Pyramid shape
        ruins = [
            [0,0,0,0,6,0,0,0,0,0],
            [0,0,0,6,6,6,0,0,0,0]
          
            ];
    } else if (raandom === 6){
        //reverseLshape
        ruins = [
            [0,0,0,0,7,0,0,0,0],
            [0,0,0,0,7,0,0,0,0],
            [0,0,0,7,7,0,0,0,0]
        ]
    }
    drawRuins();
    setTimeout(ruinsLoop, 9000);
}
function night(){
      document.getElementById('body').classList.toggle('active');
      document.getElementsByClassName('mode')[0].classList.toggle('active');
      document.getElementsByClassName('mode')[1].classList.toggle('active');
      document.getElementsByClassName('title')[6].classList.toggle('active');
      document.getElementsByClassName('title')[7].classList.toggle('active');
      document.getElementsByClassName('title')[8].classList.toggle('active');
      document.getElementsByClassName('score')[1].classList.toggle('active');
      document.getElementsByClassName('lines')[1].classList.toggle('active');
      document.getElementsByClassName('level')[1].classList.toggle('active');
    }
//initial level, lines and game speed
var level = 0;
var lines = 0;
var score = 0;
var game_speed = 1000;

//line_count keeps the count to know how many lines must be destroyed before next level.The variable is reset at each levelup.
var line_count = 0;

//The variable 'count' is used for rotation of bar shape
var count = 0;

if (localStorage.getItem('best-score') !== null){
    document.getElementsByClassName('best')[0].innerHTML = localStorage.getItem('best-score');
    document.getElementsByClassName('best')[1].innerHTML = localStorage.getItem('best-score');
} else {
    document.getElementsByClassName('best')[0].innerHTML = "0";
    document.getElementsByClassName('best')[1].innerHTML = "0";
}
     
document.getElementsByClassName('lines')[0].innerHTML = "0";
document.getElementsByClassName('lines')[1].innerHTML = "0";
document.getElementsByClassName('level')[0].innerHTML = "0";
document.getElementsByClassName('level')[1].innerHTML = "0";
document.getElementsByClassName('score')[0].innerHTML = "0";
document.getElementsByClassName('score')[1].innerHTML = "0";
drawWorld();
drawRuins();
gameLoop();
ruinsLoop();
</script>
